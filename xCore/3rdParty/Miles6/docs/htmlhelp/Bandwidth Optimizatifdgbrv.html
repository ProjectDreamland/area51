<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>Bandwidth Optimization and Channel Reliability Tips</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="">
<meta name="ms-hkwd" content="Bandwidth Optimization and Channel Reliability Tips">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Miles Sound System SDK 6.1c</a></i>
</td>
</tr>
</table>
<h1>Bandwidth Optimization and Channel Reliability Tips</h1>
<h4>Discussion</h4>
<p> Any real-world implementation of networked voice communication is likely to be a complex affair. Below are some hints on how to get the most out of the MSS voice chat codecs. </p><p><b>Use UDP networking.</b> The MSSCHTS and MSSCHTC example programs delivered with MSS use TCP/IP with the Winsock 1.X API, for simplicity. It's important to note, though, that TCP/IP is a stream-oriented rather than a packet-oriented protocol. TCP/IP provides certain guarantees of data integrity, but those guarantees come at a price: packet size and delivery latency. Because the MSS chat codecs operate on a frame-by-frame basis, it's more efficient to transport the data for each frame in an independent UDP datagram, rather than forcing the TCP layer to treat the compressed data as fragments of a continuous stream. The UDP protocol imposes significantly less overhead on data communications than TCP, but it does require significantly more programming effort to handle missing or duplicated packets in a robust fashion. If you are working on a high-performance real-time multiplayer game, chances are you're already using UDP. In such a case, your task is simply to add ASI compression and decompression support to your existing network code. </p><p><b>Optimize the size of each transmitted frame.</b> There is a subtle inefficiency in the general-purpose ASI interface that becomes evident when working with the Voxware codecs. The compressed frame size of each ASI codec is a fixed number of bytes, obtainable by querying the "Maximum frame size" attribute on the decompressor provider (or, alternatively, by querying the "Minimum input block size" attribute on an open decompressor stream). The inefficiency arises from the minuscule size of a frame of Voxware-compressed data. The V29 codec uses a 67-bit frame; the V24 codec a 54-bit frame; and the V12 codec deals with frame sizes which vary between 2 and 41 bits. The ASI frame size attribute always reports frame size at byte granularity, resulting in the effective waste of several bits per frame - which is a significant quantity of data at such small frame sizes! If your networking layer is efficient enough to take advantage of otherwise-unused bits in outgoing and incoming voice packets, or if you wish to pack multiple frames' worth of data into a single transmission unit, you may want to query the S32 "Actual bits encoded last frame" attribute in the encoder's "ASI stream" interface, to determine the exact number of bits in each compressed frame. </p><p><b>Use warping and comfort-noise masking to adapt to varying network conditions.</b> Two of the most powerful, network-friendly features of the Voxware MetaVoice codecs delivered with the Miles Sound System are "warping" and "comfort noise." The ASI codecs expose these features through the F32 "Warp factor" and S32 "Comfort noise frames" preferences in the decoders' "ASI stream" interfaces. </p><p>Warping enables the application to slow down or speed up the rate at which the Voxware decoder consumes network data. A warp factor of 1.0 causes decoded data to be produced at the standard Voxware rate of 180 bytes per frame, every frame. A warp factor of greater than 1.0 causes the Voxware codec to "slow down" the generation of output voice data, occasionally generating an extra 180-byte output frame without demanding any new input data. Interestingly, the voice does not undergo any pitch change whatsoever! Similarly, a warp factor of less than 1.0 causes the codec to "speed up" the output voice data, occasionally swallowing an input frame without generating any output data for that frame. By varying the warp factor around 1.0, your code can dynamically adjust for changes in packet arrival times without resorting to large buffers that may substantially increase perceived latency. </p><p>Comfort noise is a similar bandwidth-optimization feature. When a network connection becomes so unreliable that the latencies can't be easily handled by warping alone, you can set the "Comfort noise frames" preference to a non-zero value. Subsequent calls to the decoder's <i>ASI_stream_process</i> function will not fetch any data from the application callback, but instead will generate a "masking tone" based on the previous characteristics of the stream's voice, such that a human listener is unlikely to notice one or two missing packets. This is substantially preferable to the usual alternative of allowing the stream to drop out completely. Just set the "Comfort noise frames" preference to the number of subsequent frames you would like to mask, and the codec will do the rest. </p><p>Neither MSSCHTC.CPP nor MSSCHTS.CPP implements comfort noise or warping, or any other form of packet-arrival timing compensation. To use warping and comfort noise within the context of your own networking code, simply follow these examples: </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Get preference handles for warping and comfort noise<br>//<br>HATTRIB WARP_FACTOR,<br>COMFORT_NOISE_FRAMES;<br>RIB_INTERFACE_ENTRY ASISTR[] =<br>{<br>   PR("Warp factor",            WARP_FACTOR),<br>   PR("Comfort noise frames",   COMFORT_NOISE_FRAMES),<br>};<br>RIB_request(ASI,"ASI stream",ASISTR);<br>//<br>// Adjust Voxware warping/masking preferences<br>//<br>if (/* need to increment warp factor */)<br>{<br>   S32 w = ASI_stream_attribute(stream, WARP_FACTOR);<br>   F32 warp = *(F32 *) &w;<br>   if (warp < 3.0F) warp += 0.1F;<br>   ASI_stream_set_preference(stream, WARP_FACTOR, &warp);<br>}<br>if (/* need to decrement warp factor */)<br>{<br>   S32 w = ASI_stream_attribute(stream, WARP_FACTOR);<br>   F32 warp = *(F32 *) &w;<br>   if (warp > 0.1F) warp -= 0.1F;<br>   ASI_stream_set_preference(stream, WARP_FACTOR, &warp);<br>}<br>if (/* need to request 1 frame of comfort noise */)<br>{<br>   S32 c = ASI_stream_attribute(stream, COMFORT_NOISE_FRAMES);<br>   c = c + 1;<br>   ASI_stream_set_preference(stream, COMFORT_NOISE_FRAMES, &c);<br>}<br> </pre></font></code><p> </p>
<p><a href="Implementation Details.html">Previous Topic (Implementation Details)</a>  </p><p>
<br>
<b>Group:</b>
<a href="Implementing Voice Chat.html">Implementing Voice Chat</a></p>
<p align=center>
<a href="mailto:Miles@radgametools.com">For technical support, e-mail Miles@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/miles.htm?from=help6.1c">&#169; Copyright 1991-2001 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
