<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>Performing the Compression and Decompression</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="">
<meta name="ms-hkwd" content="Performing the Compression and Decompression">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Miles Sound System SDK 6.1c</a></i>
</td>
</tr>
</table>
<h1>Performing the Compression and Decompression</h1>
<h4>Discussion</h4>
<p> Under the ASI standard, all compression and decompression takes place within the provider's <i>ASI_stream_process</i> function. This function is extremely open-ended in nature, and completely symmetrical with respect to compression and decompression. The application simply calls it with a request for any desired amount of compressed or decompressed data, from bytes to megabytes. <i>ASI_stream_process</i> fulfills as much of the application's request as possible from the provider's own internal buffers, if any data is left over from a previous call. Subsequently, it invokes the application callback function that was originally passed to <i>ASI_stream_open</i> to request that the application send it enough source data to enable it to fulfill the compression or decompression request. In this case, MSSCHTC.CPP's <i>RECV_stream_CB</i> function is called by the <i>ASI_stream_open</i> handler to obtain compressed data from the server, one "frame" at a time, until enough frames of data have arrived to fulfill the application's request: </p><p></p><code><font size=3 color=#006000><pre><br>// ---------------------------------------------------------------------------<br>// RECV_stream_CB()<br>// Runs from client receive thread<br>// ---------------------------------------------------------------------------<br>S32 CALLBACK RECV_stream_CB(U32       user,<br>                            void FAR *dest,<br>                            S32       bytes_requested,<br>                            S32       offset)<br>{<br>   //<br>   // A seek offset of 0 occurs only when the stream is opened (initial seek to<br>   // beginning to determine stream characteristics) and when the first frame<br>   // of the stream is read after opening (when actually beginning to stream<br>   // data).  Since we are dealing with a non-seekable input stream, we<br>   // must handle this second case by maintaining a separate read and write<br>   // cursor in the frame buffer.  The second 0-offset seek is guaranteed<br>   // to occur while the initial frame data is still in the buffer.<br>   //<br>   // Most voice codecs won't perform any seek operations at all -- this<br>   // functionality is here primarily to support MP3 streaming and similar<br>   // operations.  A chat server designed strictly for use with the Voxware<br>   // codecs can safely ignore the offset parameter altogether.<br>   //<br>   //<br>   if (offset != -1)<br>   {<br>      RECV_read_cursor = offset;<br>   }<br>   //<br>   // Data will typically be requested one frame at a time by the ASI codec<br>   // (although frame header components may be requested separately, a few words<br>   // at a time).  A return value of less than bytes_requested indicates the<br>   // end of the stream has been reached.  We don't support fragmented frames,<br>   // so we'll return 0 to the codec if the client disconnects while we're<br>   // polling it for data.  Any ASI codec designed for compatibility with<br>   // IP streaming MUST accept 0-byte return values at any stage.<br>   //<br>   S32 needed = bytes_requested;<br>   while (1)<br>   {<br>      //<br>      // Get as much data as possible from frame buffer<br>      //<br>      if (RECV_read_cursor < RECV_write_cursor)<br>      {<br>         S32 n = min(needed,<br>                     RECV_write_cursor - RECV_read_cursor);<br>         memcpy(dest,<br>               &RECV_frame[RECV_read_cursor],<br>                n);<br>         dest              = ((C8 *) dest) + n;<br>         RECV_read_cursor += n;<br>         needed           -= n;<br>      }<br>      //<br>      // If all requested data has been read, return<br>      //<br>      if (needed <= 0)<br>      {<br>         //<br>         // Keep read/write cursors in first half of frame buffer<br>         //<br>         if (RECV_read_cursor >= RECEIVE_FRAME_SIZE)<br>         {<br>            RECV_read_cursor  -= RECEIVE_FRAME_SIZE;<br>            RECV_write_cursor -= RECEIVE_FRAME_SIZE;<br>         }<br>         return bytes_requested;<br>      }<br>      //<br>      // We need more data -- read it into the frame buffer<br>      //<br>      S32 result = NET_poll_for_data(&RECV_frame[RECV_write_cursor],<br>                                      needed);<br>      if (result == -1)<br>      {<br>         //<br>         // Client disconnected, return 0 to abort current frame<br>         //<br>         return 0;<br>      }<br>      if (result == 0)<br>      {<br>         //<br>         // No data available yet<br>         //<br>         Sleep(10);<br>      }<br>      else<br>      {<br>         //<br>         // Advance the write cursor<br>         //<br>         RECV_write_cursor += result;<br>      }<br>      //<br>      // Block until more data comes in or server disconnects<br>   }<br>}<br></pre></font></code><p></p><p> As the comments suggest, this code is somewhat more robust than it has to be for simple voice communication with the Voxware codecs. Many ASI decompressors, notably the MP3 decoder, can output different PCM data formats depending on the exact format of the compressed source data. In such a case, the application needs to be able to determine the sample format required to play the decoded data immediately after calling the <i>ASI_stream_open</i> function. So a typical ASI codec must examine the first few bytes of the data when opening a stream, in order to report the stream's format to the application. This is the only case in which a "seek" operation must be supported by the codec when dealing with streamed data, so it's a good practice to support valid offset parameters in an ASI decompressor's callback function if you expect to support more general codecs in the future. (Typically the ability to seek 1 or 2 KB backwards in a stream after the first frame is fetched is sufficient for most popular data formats). </p><p>Turning uncompressed PCM data from the input API or data file into compressed data suitable for transmission to the server is an almost identical process, thanks to the inherent symmetry of the ASI specification. MSSCHTC.CPP's <i>transmit_ASI_thread_procedure</i> calls the transmit ASI provider as follows: </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// See if more transmit data is needed<br>//<br>if (current_send_offset == TRANSMIT_PACKET_SIZE)<br>{<br>   //<br>   // Request data from ASI encoder to send to server<br>   //<br>   // This will block in XMIT_stream_CB( ) until enough input<br>   // data is available to satisfy the request<br>   //<br>   S32 amount = XMIT_stream_process(transmit_stream,<br>                                    send_buffer,<br>                                    TRANSMIT_PACKET_SIZE);<br>   if (amount != TRANSMIT_PACKET_SIZE)<br>   {<br>      //<br>      // Bad read<br>      //<br>      active = 0;<br>      return 0;<br>   }<br>   current_send_offset = 0;<br>}<br></pre></font></code><p></p><p> As in the receiver code above, the <i>XMIT_stream_process</i> function calls the application-supplied callback function <i>XMIT_stream_CB</i> to fetch enough data to fulfill the application's request. In this case, <i>XMIT_stream_CB</i> blocks until sufficient data is available from the input API: </p><p></p><code><font size=3 color=#006000><pre><br>// ---------------------------------------------------------------------------<br>// XMIT_stream_CB( )<br>// ---------------------------------------------------------------------------<br>S32 CALLBACK XMIT_stream_CB(U32       user,<br>                            void FAR *dest,<br>                            S32       bytes_requested,<br>                            S32       offset)<br>{<br>   //<br>   // Block transmission thread in this routine until specified<br>   // number of bytes available from input, or disconnection occurs<br>   //<br>   S32 bytes_sent = 0;<br>   while (bytes_requested > 0)<br>   {<br>      //<br>      // Allow other threads to run<br>      //<br>      Sleep(3);<br>      //<br>      // Exit if transmit thread killed by main thread<br>      //<br>      // Returning 0 here will cause transmit_thread_procedure() to exit<br>      // when its ASI_stream_process( ) call fails<br>      //<br>      if (!threads_active)<br>      {<br>         return 0;<br>      }<br>      //<br>      // Get input buffer to send<br>      //<br>      if ((input_buffer_tail == -1) ||<br>          (input_buffer_tail == input_buffer_head))<br>      {<br>         //<br>         // No input buffers available<br>         //<br>         continue;<br>      }<br>      //<br>      // Transmit data from input buffer at queue tail<br>      //<br>      C8 FAR *src       = &input_buffer [input_buffer_tail] [input_read_offset];<br>      S32     src_avail = INPUT_BUFFER_SIZE - input_read_offset;<br>      S32 send_amount = min(bytes_requested,<br>                            src_avail);<br>      memcpy(dest,<br>             src,<br>             send_amount);<br>      dest               = ((C8 *) dest) + send_amount;<br>      input_read_offset += send_amount;<br>      bytes_requested   -= send_amount;<br>      bytes_sent        += send_amount;<br>      if (input_read_offset == INPUT_BUFFER_SIZE)<br>      {<br>         //<br>         // Entire buffer has been sent; advance tail pointer<br>         //<br>         if (input_buffer_tail == N_INPUT_BUFFERS-1)<br>         {<br>            input_buffer_tail = 0;<br>         }<br>         else<br>         {<br>            ++input_buffer_tail;<br>         }<br>         input_read_offset = 0;<br>      }<br>   }<br>   return bytes_sent;<br>}<br></pre></font></code><p></p><p> Use of the ASI codec interface in MSSCHTS.CPP is very similar to the above examples in MSSCHTC.CPP. </p>
<p><a href="Integrating the Code3o2s18.html">Next Topic (Integrating the Codecs with your Networking Architecture)</a>  </p><p><a href="Accessing the Codecsj7rin4.html">Previous Topic (Accessing the Codecs Directly with the RIB Interface)</a>  </p><p>
<br>
<b>Group:</b>
<a href="Implementing Voice Chat.html">Implementing Voice Chat</a></p>
<p align=center>
<a href="mailto:Miles@radgametools.com">For technical support, e-mail Miles@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/miles.htm?from=help6.1c">&#169; Copyright 1991-2001 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
