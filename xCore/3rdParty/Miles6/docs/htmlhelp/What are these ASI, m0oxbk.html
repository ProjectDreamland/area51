<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>What are these ASI, M3D, and FLT files? What is RIB?</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="">
<meta name="ms-hkwd" content="What are these ASI, M3D, and FLT files? What is RIB?">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Miles Sound System SDK 6.1c</a></i>
</td>
</tr>
</table>
<table>
<tr valign=top><td><b><p>Q:</p></b></td><td><b><p>What are these ASI, M3D, and FLT files? What is RIB?</p></b></td></tr>
<tr valign=top><td><p>A:</p></td><td><p> RIB stands for RAD Interface Broker - it is RAD's mechanism for expanding and enhancing the system through the use of dynamically-loadable modules. These modules, called RIBs, are designed in conformance with the new RAD Interface Broker (RIB) standard. ASI, M3D and FLT files are all RIB-based loadable modules. </p><p>ASI files are sound codecs - MP3 is provided in the <b>MP3DEC.ASI</b> file, for example. </p><p>M3D files are 3D sound providers - EAX support is provided in the <b>MSSEAX.M3D</b> file. There are quite a few M3D files now. </p><p>FLT files are digital sound filters - low-pass filtering is performed in the <b>LowPass.FLT</b> file. There are a bunch of FLT files! </p><p>This is all you really need to know about RIB to use Miles, but if you are interesting in the technical underpinnings of RIB, read on... </p><p>The RIB standard allows either MSS or the application itself to scan a directory for installable modules, load them, query their attributes, and take advantage of the features they offer at runtime, all in a manner that's completely transparent to your application. RIBs deliver many of the same benefits of "component-oriented" design that are commonly associated with more complex and proprietary industry standards such as Microsoft's COM model, but on an open, cross-platform basis, and with several key features designed to avoid many of the headaches that eventually come to plague users of other runtime object models. </p><p>As with most component-based models in use today, RIB components represent individual functions and data elements as collective members of named interfaces. Unlike more familiar object models such as those associated with MS COM and even C++ itself, however, an application's view of a particular RIB interface and its elements is determined completely by the application itself, and not the RIB component provider or any of its header files. The MSS RIB manager implements true dynamic binding at no additional cost in runtime performance. By way of illustration, three different ways to instantiate the same object might look like: </p><p><b>C++ With Static Binding</b> </p><p></p><code><font size=3 color=#006000><pre><br>MyStream = new MP3Stream;<br></pre></font></code><p></p><p> <b>MS COM With Runtime Binding</b> </p><p></p><code><font size=3 color=#006000><pre><br>MP3StreamFactory->QueryInterface(IID_Stream,<br>                                 (void **) &MyStream);<br></pre></font></code><p></p><p> <b>RAD Interface Broker With Runtime Binding</b> </p><p></p><code><font size=3 color=#006000><pre><br>STR_OPEN STR_open;<br>...<br>HATTRIB OUTPUT_SAMPLE_RATE<br>...<br>RIB_INTERFACE_ENTRY MyStreamInterface[] =<br>{<br>   FN(STR_attribute),<br>   FN(STR_open),<br>   FN(STR_close),<br>   FN(STR_process),<br>   FN(STR_set_preference),<br>   AT("Output sample rate",    OUTPUT_SAMPLE_RATE),<br>   AT("Output sample width",   OUTPUT_BITS),<br>   AT("Output channels",       OUTPUT_CHANNELS)<br>}<br>HSTREAM STR = RIB_find_file_provider("Audio stream",<br>                                     "Input file types",<br>                                     "*.MP3");<br>RIB_request(STR,<br>            "Audio stream",<br>             MyStreamInterface);<br>MyStreamHandle = STR_open();<br></pre></font></code><p></p><p> It's apparent at a glance that the RIB-based example is, if nothing else, more complex. What benefits are being gained with all that extra code? The answer lies in a fundamental aspect of the RIB system's design: RIB interfaces specify content, not structure. RIB components never reveal the exact layout of their interfaces to the application. A RIB interface name is only used to refer to a collection of available, related functions and data attributes. Unlike a C++ class, a RIB interface does not expose implementation details which have to be artificially segregated from the outside world with "private" or "public" labels. And unlike an MS COM interface, a RIB interface does not introduce dangerous dependencies on the underlying language's virtual-function table model, including the number of functions an interface provider offers and the order in which its function prototypes appear in a class declaration. As suggested by the example above, each RIB application is able to specify its own view of the functions and data exposed by its component providers. The binding of the provider's resources with the application's declarations takes place dynamically, via the <i>RIB_request</i> function. There are several advantages to this approach: </p><p>- No more obsolete header files. A RIB component's header file contains only the typedef'ed prototypes for the functions exported by the component at its time of release. The application declares variables of these types to receive function pointers when <i>RIB_request</i> is called to resolve its requested functions by name. Data attributes (named read-only values) and preferences (named readable/writable values) are resolved in a similar manner, through the use of tokens which are passed down from the provider to the caller via <i>RIB_request</i>. </p><p>- No more broken interfaces. A RIB interface does not contain or imply any implementation details such as the order in which its functions appear in an internal virtual-method table. Consequently, new functions and data members may be exposed in subsequent releases, without "breaking" any existing application compiled with an older version of the component's header file. Similarly, different providers of the same interface (e.g., an MPEG audio decoder and an IMA ADPCM audio decoder) can export provider-specific attributes and functions, which the application can either enumerate or ask for explicitly at runtime. Applications are also free to request functions and attributes which may not be supported by all providers of a given interface, taking advantage of optional features when available and degrading gracefully otherwise. </p><p>- Full runtime browsability. All communication between RIB components and their calling applications takes place via functions, attributes, and preferences whose names are presented as plain-text ASCII strings. This applies as well to the names of the components' interfaces themselves. The RIB manager API allows the names, members, and types of all interface elements to be enumerated in a standardized fashion, making it possible for general-purpose component browsers to be developed for all providers of a given interface. </p><p>What does this mean to you, as the creator of your own MSS applications? The good news is that we've made it easy for you to take advantage of the new RIB providers without getting involved in the details of the RIB component model. MSS's API has been expanded to make access to both the 3D audio and MPEG compression feature sets as painless as possible. Most application authors will never come into direct contact with the RIB manager API that's built into MSS. For the curious, however, the complete RIB API documentation is available in RIB.H, with the new audio stream interface documented in MSSASI.H. Other RIB interfaces, including the mixer services and 3D audio services, are so intimately associated with the MSS system that their declarations are part of MSS.H itself. </p><p>In short, RAD believes that the component-oriented RAD Interface Broker model is the best way to make sure that MSS grows with your needs. We feel it's one of the more exciting features of the new system, even though its implications may be lost amidst the excitement of the new features and tools! </p></td></tr>
</table>
<p><a href="The Internet voice cx1l30f.html">Previous Topic (The Internet voice chat example has a lot of latency or it doesn't work on my LAN - what's going on?)</a>  </p><p>
<br>
<b>Group:</b>
<a href="FAQs and How Tos.html">FAQs and How Tos</a><br>
<b>Related FAQs:</b>
<a href="I want a small instanf5kll.html">I want a small installation - do I need all of the files in the \redist directories?</a></p>
<p align=center>
<a href="mailto:Miles@radgametools.com">For technical support, e-mail Miles@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/miles.htm?from=help6.1c">&#169; Copyright 1991-2001 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
